<!-- index.html (solo el script de filtros) -->
<script>
const qs = new URLSearchParams(location.search);
const LOCK_CLIENT = qs.get('lockClient') === '1';
const LOCK_PROJECT = qs.get('lockProject') === '1';
const Q_CLIENT = qs.get('client') || null;
const Q_PROJECT = qs.get('project') || null;

const LS_KEY = 'grid-filters-v1';

function loadPersisted() {
  try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch { return {}; }
}
function savePersisted(state) {
  localStorage.setItem(LS_KEY, JSON.stringify(state || {}));
}

let state = loadPersisted();

if (Q_CLIENT) state.client = Q_CLIENT;
if (Q_PROJECT) state.project = Q_PROJECT;

async function applyFiltersFromState() {
  // aquí llamas a /api/filters para poblar dropdowns como ya lo haces
  // y luego aplicas state.{client,project,owner,status,platform}
  // IMPORTANTE: si LOCK_CLIENT/LOCK_PROJECT, deshabilita esos chips/selects.
  if (LOCK_CLIENT) disableClientSelector();
  if (LOCK_PROJECT) disableProjectSelector();
  await reloadGrid(); // tu función existente
}

function clearFilters() {
  // borra todo MENOS los bloqueados
  const s = {};
  if (LOCK_CLIENT && state.client) s.client = state.client;
  if (LOCK_PROJECT && state.project) s.project = state.project;
  state = s;
  savePersisted(state);
  applyFiltersFromState();
}

// Cada vez que el usuario cambia un filtro:
function onFilterChange(key, value) {
  if (key === 'client' && LOCK_CLIENT) return;
  if (key === 'project' && LOCK_PROJECT) return;
  state[key] = value;
  savePersisted(state);
  reloadGrid();
}

document.addEventListener('DOMContentLoaded', applyFiltersFromState);
</script>
